<!doctype html>
<html lang="en">
<head>
  <title>GBJam 11 - Space</title>
  <style>

html, body {
  background-color: #000;
  font-family: sans-serif;
  font-size: 18px;
  line-height: 24px;
  color: #ffffff;
  text-align: center;
}

a {
  color: #6772a9;
  text-decoration: none;
}

a:hover, a:active {
  color: #ffffff;
  text-decoration: underline;
}

#cnv {
  display: block;
  width: 640px;
  height: 576px;
  margin: 16px auto;
  image-rendering: pixelated;
  border: 1px solid #3a3277;
  border-radius: 8px;
}

#controls {
  text-align: left;
  width: 275px;
  margin: 16px auto;
  padding: 16px;
  background-color: #3a3277;
  border-radius: 8px;
}

#controls > p {
  margin: 0 0 8px 0;
  padding: 0;
  font-weight: bold;
  text-decoration: underline;
  text-align: center;
}

#controls > strong {
  display: inline-block;
  width: 120px;
}

#fps {
  color: #3a3277;
}
  </style>
  <script src="./howler.core.min.js"></script>
</head>
<body>
  <canvas id="cnv" width="160" height="144"></canvas>
  <div id="controls">
    <p>Controls</p>
    <strong>Arrow Keys</strong> Move</br >
    <strong>Z</strong> Pick up / put down<br />
    <strong>X</strong> Jump<br />
    <strong>Enter</strong> Try again<Br />
    <strong>Music</strong><select id="musicVol">
      <option value="0">Off</option>
      <option value="0.25">25%</option>
      <option value="0.5" selected>50%</option>
      <option value="0.75">75%</option>
      <option value="1.00">100%</option>
    </select>
    <strong>Sfx</strong><select id="sfxVol">
      <option value="0">Off</option>
      <option value="0.25">25%</option>
      <option value="0.5" selected>50%</option>
      <option value="0.75">75%</option>
      <option value="1.00">100%</option>
    </select>
  </div>
  <p id="fps">FPS: ?</p>
  <p>
    &copy; Copyright 2023 <a href="https://pulp.biz">Pocket Pulp LLC</a>, 0BSD
  </p>
  <script>
const fps = document.getElementById('fps');
const cnv = document.getElementById('cnv');
const ctx = cnv.getContext('2d');
const world = [];
const origWorld = [];
const colors = ['#000000', '#3a3277', '#6772a9', '#ffffff'];
const cameraLagNormal = 0.11;
const cameraLagExplosion = 0.04;
const physicsAirDrag = 0.85;
const physicsGroundDrag = 0.8;
const physicsGravityDrag = 0.98;
const physicsLadderDrag = 0.7;
const physicsMove = 0.5;
const physicsGravity = [0.2, 0.2, 0.35, 0.35];
const physicsJump = -6;
const grabFrames = 10;
const placeFrames = 6;
const epsilon = 0.0001;
const particleWhiteSparkle = [
  9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
  11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
  390, 390, 390, 390, 392, 392, 392, 392, 390, 390, 390, 390, 392, 392, 392, 392,
  390, 390, 390, 390, 390, 390, 390,
];
const maskNoItem = 0xc0007fff;
const maskNoBg = 0xfffff000;
let coinCount = 0;
let totalCoinCount = 0;
let totalFrameCount = 0;
let worldWidth = 0;
let worldHeight = 0;
let userX = 0;
let userY = 0;
let forceX = 0;
let forceY = 0;
let velX = 0;
let velY = 0;
let userDead = 0;
let grounded = false;
let groundedPos = [0, 0];
let grabItem = 0;
let pushed = false;
let grabbing = 0;
let grabDir = 0;
let grabSource = 0;
let placing = 0;
let placePos = [0, 0];
let placeUserMove = [0, 0];
let itemFalling = [];
let explosion = [];
let exploded = [];
let particles = [];
let finalHome = [0, 0];
let prizeDoors = [];
let coinDoors = [];
let beatGame = 0;
let cameraX = 0;
let cameraY = 0;
let followX = 0;
let followY = 0;
let follow = 2;
let checkpoint = false;
let prizes = [];
let wasTargetingExplosions = 0;
const input = {
  up: false,
  down: false,
  left: false,
  right: false,
  reset: false,
  hitReset: false,
  jump: false,
  hitJump: false,
  grab: false,
  hitGrab: false,
  debugUp: false,
  debugDown: false,
  debugLeft: false,
  debugRight: false,
  debugSpace: false
};

ctx.fillStyle = '#3a3277';
ctx.fillRect(0, 0, cnv.width, cnv.height);

const img = new Image();
img.src = './gfx.png';
const userImg = new Image();
userImg.src = './user.png';

const musicVol = document.getElementById('musicVol');
musicVol.selectedIndex = 2;
const sfxVol = document.getElementById('sfxVol');
sfxVol.selectedIndex = 2;

const music = new Howl({
  src: ['song.mp3'],
  autoplay: true,
  loop: true,
  volume: 0.5,
});

musicVol.addEventListener('input', function(){
  const v = parseFloat(this.options[this.selectedIndex].value);
  music.volume(v);
});

sfxVol.addEventListener('input', function(){
  const v = parseFloat(this.options[this.selectedIndex].value);
  console.log('TODO: set sfx to', v);
});

function ilerp(a, b, t) {
  return Math.round(a + (b - a) * t);
}

function redraw() {
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.fillRect(0, 0, cnv.width, cnv.height);
  const coinFrame = Math.floor(totalFrameCount / 6) % 7;
  const xi = Math.floor(-cameraX / 9);
  const xf = Math.floor(-cameraX) - xi * 9;
  const yi = Math.floor(-cameraY / 9);
  const yf = Math.floor(-cameraY) - yi * 9;
  for (let y = -1; y < 16; y++) {
    const wy = y - yi;
    for (let x = -1; x < 18; x++) {
      const wx = x - xi;
      const k = (
        wx < 0 || wx >= worldWidth ||
        wy < 0 || wy >= worldHeight
      ) ? 64 : world[wx + wy * worldWidth];
      const k1 = k & 0x7fff;
      if (k1 > 0)
        drawTile(k1, x * 9 + xf, y * 9 + yf);
      let k2 = (k >> 15) & 0x7fff;
      if (k2 > 0) {
        if (k2 === 26) // coin
          k2 += coinFrame;
        drawTile(k2, x * 9 + xf, y * 9 + yf);
      }
    }
  }

  if (grabItem && itemFalling.length > 0) {
    // draw falling items
    const t = grabbing / grabFrames;
    for (const item of itemFalling) {
      const [ax, ay, it] = item;
      drawTile(
        it,
        Math.floor(-cameraX) + ax * 9,
        Math.floor(-cameraY) + ilerp(ay * 9, ay * 9 + 9, t)
      );
    }
  }

  if (grabItem) {
    if (grabbing) {
      const t = grabbing / grabFrames;
      drawTile(
        grabItem,
        Math.floor(userX) + Math.floor(-cameraX) +
          ilerp(grabDir * 9, 0, t),
        Math.floor(userY) + Math.floor(-cameraY) +
          ilerp(0, -9, t)
      );
    } else if (placing) {
      const t = placing / placeFrames;
      drawTile(
        grabItem,
        Math.floor(-cameraX) +
          ilerp(Math.floor(userX), placePos[0] * 9, t),
        Math.floor(-cameraY) +
          ilerp(Math.floor(userY) - 9, placePos[1] * 9, t)
      );
    } else {
      drawTile(
        grabItem,
        Math.floor(userX) + Math.floor(-cameraX),
        Math.floor(userY) + Math.floor(-cameraY) - 9
      );
    }
  }

  // draw user
  if (!userDead) {
    drawUser(0, false,
      Math.floor(userX) + Math.floor(-cameraX),
      Math.floor(userY) + Math.floor(-cameraY)
    );
  }

  // grab highlight
  if (!grabItem && grounded && pushed) {
    const ax = Math.floor(userX / 9) + pushed;
    const { item } = getForce(ax, Math.floor(userY / 9));
    if (item > 0) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.drawImage(img, 18 + ((totalFrameCount >> 2) % 11) * 9, 9, 9, 9,
        Math.floor(-cameraX) + Math.floor(userX / 9) * 9 + pushed * 9,
        Math.floor(-cameraY) + Math.floor(userY / 9) * 9,
        9, 9
      );
    }
  }

  // placement highlight
  if (grounded && grabItem && !isPrize(grabItem) && !grabbing) {
    const x = Math.floor(-cameraX) + groundedPos[0] * 9;
    const y = Math.floor(-cameraY) + groundedPos[1] * 9;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(img, 36 + ((totalFrameCount >> 2) % 6) * 9, 18, 9, 9, x, y, 9, 9);
  }
  if (grabItem && isPrize(grabItem) && !grabbing) {
    const p = prizes.find(p => p.item === grabItem);
    const x = Math.floor(-cameraX) + p.hx * 9;
    const y = Math.floor(-cameraY) + (p.hy + 1) * 9;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(img, 36 + ((totalFrameCount >> 2) % 6) * 9, 18, 9, 9, x, y, 9, 9);
  }


  // draw particles
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  for (let i = 0; i < particles.length; i++) {
    const p = particles[i];
    p.x += p.dx;
    p.y += p.dy;
    p.dy += p.ddy;
    const f = p.frames[p.frame++];
    if (p.frame >= p.frames.length) {
      particles.splice(i, 1);
      i--;
    }
    const fx = (f % (64 * 3)) * 3;
    const fy = Math.floor(f / (64 * 3)) * 3;
    ctx.drawImage(img, fx, fy, 3, 3,
      Math.floor(-cameraX) + Math.floor(p.x) - 1,
      Math.floor(-cameraY) + Math.floor(p.y) - 1,
      3, 3
    );
  }

  // draw coin count
  {
    drawTile(26, 2, 2);
    const cstr = coinCount + '';
    for (let i = 0; i < cstr.length; i++) {
      const ch = cstr.charCodeAt(i) - 48;
      drawTile(33 + ch, 11 + i * 8, 2);
    }
  }

  if (!follow) {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.strokeStyle = '#ff0';
    ctx.beginPath();
    ctx.rect(
      Math.floor(followX - cameraX) - 0.5,
      Math.floor(followY - cameraY) - 0.5,
      161,
      145
    );
    ctx.lineWidth = 1;
    ctx.stroke();
  }
}

function isLadder(bg) {
  return bg === 197 || bg === 1221 || bg === 2245 || bg === 3269;
}

function getForce(cx, cy) {
  if (cx < 0 || cx >= worldWidth || cy >= worldHeight)
    return { fx: 0, fy: 0, solid: 1, bg: 3136, item: 0 };
  if (cy < 0)
    return { fx: 0, fy: 0, solid: 1, bg: 65, item: 0 };
  const w = world[cx + cy * worldWidth];
  const bg = w & 0xfff;
  let solid = (w >> 15) !== 0 ? 1 : 0;
  let item = (w >> 15) & 0x3fff;
  if (item === 26) { // coin
    solid = (w & 0x40000000) !== 0;
    item = 0;
  }
  if (
    (item < 10 && item !== 4) || // no TNT elements
    (item >= 10 && item <= 20) || // no fuses
    isPrizeDoors(item) || // no doors
    isCoinDoors(item)
  ) {
    item = 0; // prevent grabbing
  }
  let fx = 0;
  const { add: itAdd, mul: itMul } = itemWeight(grabItem);
  let fy = physicsGravity[((w >> 10) & 3)] * itMul + itAdd;
  if (isLadder(bg)) // ladder
    fy = 0;
  // check falling items
  for (const item2 of itemFalling) {
    const [ax, ay, it] = item2;
    if (cx === ax && (cy === ay || cy === ay + 1)) {
      solid = 1;
      item = it;
    }
  }
  return { fx, fy, solid, bg, item };
}

function isPrize(item) {
  return item === 21 || item === 22 || item === 23 || item === 24 || item === 25;
}

function isPrizeHome(bg) {
  return bg === 85 || bg === 86 || bg === 87 || bg === 88 || bg === 89;
}

function isPrizeDoors(item) {
  return item === 2180 || item === 2244;
}

function isCoinDoors(item) {
  return item === 2182 || item === 2183 || item === 2246 || item === 2247;
}

function itemWeight(item) {
  item = item & 0xfff;
  if (item === 0 || item === 4 || isPrize(item)) {
    return { add: 0, mul: 1 };
  } else if (item === 1024) // wood box
    return { add: 0, mul: 2 };
  else if (item === 1025) // jetpack
    return { add: 0, mul: 0.5 };
  else if (item === 1026) // balloon
    return { add: -0.25, mul: 1 };
  console.log('unknown weight:', item);
  return { add: 0, mul: 1 };
}

function explode(cx, cy, blink, blinkLeft) {
  if (cx < 0 || cx >= worldWidth || cy < 0 || cy >= worldHeight)
    return;
  const k = cx + cy * worldWidth;
  const item = (world[k] >> 15) & 0xfff;
  if (item === 6 || item === 8 || (item >= 10 && item <= 20)) {
    if (item < 10)
      world[k] = (world[k] & maskNoItem) | ((item + 1) << 15);
    explosion.push({
      x: cx,
      y: cy,
      state: 1,
      blink,
      blinkLeft
    });
  }
}

function updateCheckpointTiles(x, y, d) {
  const w = worldWidth;
  const k = x + y * w;
  world[k + 0 + 0] = (world[k + 0 + 0] & maskNoBg) | ((world[k + 0 + 0] & 0xfff) + d);
  world[k + 0 + 1] = (world[k + 0 + 1] & maskNoBg) | ((world[k + 0 + 1] & 0xfff) + d);
  world[k + w + 0] = (world[k + w + 0] & maskNoBg) | ((world[k + w + 0] & 0xfff) + d);
  world[k + w + 1] = (world[k + w + 1] & maskNoBg) | ((world[k + w + 1] & 0xfff) + d);
}

function overlaps(x, y) {
  const cx = Math.floor(x / 9);
  const cy = Math.floor(y / 9);
  const cw = Math.ceil((x + 9) / 9);
  const ch = Math.ceil((y + 9) / 9);
  let collide = false;
  let spike = false;
  let home = false;
  for (let iy = cy; iy < ch; iy++) {
    for (let ix = cx; ix < cw; ix++) {
      const { solid, bg } = getForce(ix, iy);
      if (ix === finalHome[0] && iy === finalHome[1])
        home = true;
      if (solid) {
        collide = true;
        if (bg === 65 || bg === 1089 || bg === 2113 || bg === 3137)
          spike = true;
      }
    }
  }
  return { collide, spike, home };
}

function explodeItem() {
  if (isPrize(grabItem)) // don't explode prizes lol
    return;
  randomParticles(10, userX + 5, userY + 5 - 9, particleWhiteSparkle);
  world[grabSource] = (world[grabSource] & maskNoItem) | (grabItem << 15);
  grabItem = 0;
}

function explodeUser() {
  randomParticles(10, userX + 5, userY + 5, particleWhiteSparkle);
  userDead = 1;
  forceX = 0;
  forceY = 0;
  velX = 0;
  velY = 0;
}

function checkBeatGame() {
  if (beatGame)
    return;
  for (const p of prizes) {
    if (!p.done)
      return;
  }
  const cx = Math.floor((userX + 5) / 9);
  const cy = Math.floor((userY + 5) / 9);
  if (cx === finalHome[0] && cy === finalHome[1])
    beatGame = 1;
}

function randomParticles(count, x, y, frames) {
  for (let part = 0; part < count; part++) {
    const ang = Math.random() * Math.PI * 2;
    const mag = Math.random() * 0.8;
    particles.push({
      x,
      y,
      dx: Math.cos(ang) * mag,
      dy: Math.sin(ang) * mag,
      ddy: 0,
      frame: Math.floor(Math.random() * 10),
      frames
    });
  }
}

function restoreCheckpoint() {
  if (!checkpoint)
    return;
  for (let i = 0; i < origWorld.length; i++)
    world[i] = origWorld[i];
  // remove exploded cells
  for (const k of exploded) {
    const item = (world[k] >> 15) & 0xfff;
    world[k] = world[k] & maskNoItem;
  }
  // restore prizes
  for (const p of prizes) {
    const k = p.done ? p.hx + p.hy * worldWidth : p.x + p.y * worldWidth;
    world[k] = (world[k] & maskNoItem) | (p.item << 15);
  }
  if (!checkpoint.init)
    updateCheckpointTiles(checkpoint.x, checkpoint.y, 2);
  userX = checkpoint.x * 9 + (checkpoint.init ? 0 : 5);
  userY = checkpoint.y * 9 + (checkpoint.init ? 0 : 9);
  userDead = 0;
  grabItem = 0;
  forceX = 0;
  forceY = 0;
  velX = 0;
  velY = 0;
  follow = 2;
}

function addCoin(){
  coinCount++;
  if (coinCount === 70){
    for (const k of coinDoors){
      world[k] = world[k] & maskNoItem;
      exploded.push(k);
    }
  }
}

function checkCoin(cx, cy) {
  const k = cx + cy * worldWidth;
  if (cx >= 0 && cx < worldWidth && cy >= 0 && cy < worldHeight &&
    ((world[k] >> 15) & 0xfff) === 26) {
    // collected coin!
    world[k] = world[k] & maskNoItem;
    exploded.push(k);
    addCoin();
  }
}

function start() {
  function tick() {
    totalFrameCount++;
    if (input.debugUp   ){ follow = 0; cameraY -= 2; }
    if (input.debugDown ){ follow = 0; cameraY += 2; }
    if (input.debugLeft ){ follow = 0; cameraX -= 2; }
    if (input.debugRight){ follow = 0; cameraX += 2; }
    if (input.debugSpace){ follow = 2;               }

    const cx = Math.floor((userX + 5) / 9);
    const cy = Math.floor((userY + 5) / 9);

    // check for coin collection
    {
      const cx = Math.floor(userX / 9);
      const cy = Math.floor(userY / 9);
      const cw = Math.ceil((userX + 9) / 9);
      const ch = Math.ceil((userY + 9) / 9);
      for (let iy = cy; iy < ch; iy++) {
        for (let ix = cx; ix < cw; ix++) {
          checkCoin(ix, iy);
        }
      }
    }

    forceX = 0;
    forceY = 0;
    let v = 0;
    let h = 0;

    if (userDead) {
      userDead++;
      if (userDead >= 60)
        restoreCheckpoint();
    } else if (beatGame) {
      beatGame++;
      // TODO: something cool
    } else if (grabbing) {
      grabbing++;
      if (grabbing >= grabFrames) {
        grabbing = 0;
        if (grabItem === 4) // automatically drop fuse
          grabItem = 0;
        // commit falling items
        for (const item of itemFalling) {
          const [ax, ay, it] = item;
          const k = ax + (ay + 1) * worldWidth;
          world[k] = (it << 15) | world[k];
        }
        itemFalling = [];
      }
    } else if (placing) {
      placing++;
      const t = placing / placeFrames;
      userY = ilerp(placeUserMove[0], placeUserMove[1], t);
      if (placing >= placeFrames) {
        placing = 0;
        const k = placePos[0] + placePos[1] * worldWidth;
        world[k] = (grabItem << 15) | world[k];
        if (isPrize(grabItem)) {
          const p = prizes.find(p => p.item === grabItem);
          p.done = true;
          // placed prize!
          if (p.item === 25) { // power
            for (const k of prizeDoors){
              world[k] = world[k] & maskNoItem;
              exploded.push(k);
            }
          }
          if (prizes.every(p => p.done)) {
            // seal doors
            for (const k of prizeDoors){
              world[k] = origWorld[k];
              while (true) {
                const i = exploded.indexOf(k);
                if (i < 0)
                  break;
                exploded.splice(i, 1);
              }
            }
            // remove last checkpoint
            if (checkpoint && !checkpoint.init)
              updateCheckpointTiles(checkpoint.x, checkpoint.y, -2);
            // set checkpoint inside ship
            checkpoint = {
              init: true,
              x: Math.floor(userX / 9),
              y: Math.floor(userY / 9) - 1,
            };
          }
        }
        grabItem = 0;
      }
    } else if (explosion.length > 0) {
      // do nothing
    } else {
      h = input.left && !input.right ? -1 : input.right ? 1 : 0;
      v = input.up && !input.down ? -1 : input.down ? 1 : 0;

      if (!grabItem && input.hitGrab && grounded && pushed && !overlaps(userX, userY - 9).collide) {
        const ax = Math.floor(userX / 9) + pushed;
        const { item } = getForce(ax, Math.floor(userY / 9));
        if (item > 0) {
          const k = ax + cy * worldWidth;
          world[k] = world[k] & maskNoItem;
          // check for falling items
          itemFalling = [];
          for (let ay = cy - 1; ay >= 0; ay--) {
            const { item } = getForce(ax, ay);
            if (!item)
              break;
            const k = ax + ay * worldWidth;
            world[k] = world[k] & maskNoItem;
            itemFalling.push([ax, ay, item]);
          }
          forceX = 0;
          forceY = 0;
          velX = 0;
          velY = 0;
          userX = Math.floor(userX);
          userY = Math.floor(userY);
          grabbing = 1;
          grabDir = pushed;
          grabItem = item;
          grabSource = k;
          pushed = false;
          if ((grabItem & 0xfff) === 4) {
            const k = ax + (cy + 1) * worldWidth;
            world[k] = (world[k] & maskNoItem) | (6 << 15);
            explode(ax, cy + 1, 30, 5);
            exploded.push(k - worldWidth); // remove fuse
          }
        }
      } else if (grabItem && input.hitGrab && grounded) {
        placePos = [groundedPos[0], groundedPos[1] - 1];
        let canPlace = true;
        if (isPrize(grabItem)) {
          // verify we can place it here, at home
          const p = prizes.find(p => p.item === grabItem);
          canPlace = placePos[0] === p.hx && placePos[1] === p.hy;
        } else {
          // don't allow other objects in prize homes
          canPlace = !prizes.find(p => placePos[0] === p.hx && placePos[1] === p.hy);
        }
        if (canPlace) {
          forceX = 0;
          forceY = 0;
          velX = 0;
          velY = 0;
          placing = 1;
          placeUserMove = [userY, userY - 9];
        }
      } else if (input.hitJump && grounded) {
        forceY += physicsJump;
      } else if (input.hitReset) {
        restoreCheckpoint();
      }
    }

    const { fx, fy, bg } = getForce(cx, cy);
    forceX += h * physicsMove;
    if (isLadder(bg))
      forceY += v * physicsMove;
    velX += fx + forceX;
    velY += fy + forceY;
    velX *= isLadder(bg) ? physicsLadderDrag :
      grounded ? physicsGroundDrag : physicsAirDrag;
    velY *= isLadder(bg) ? physicsLadderDrag : physicsGravityDrag;

    // check for checkpoint
    let checkX = -1;
    let checkY = -1;
    if (bg === 128 || bg === 1024 + 128 || bg === 2048 + 128 || bg === 3072 + 128) {
      checkX = cx;
      checkY = cy;
    } else if (bg === 129 || bg === 1024 + 129 || bg === 2048 + 129 || bg === 3072 + 129) {
      checkX = cx - 1;
      checkY = cy;
    } else if (bg === 192 || bg === 1024 + 192 || bg === 2048 + 192 || bg === 3072 + 192) {
      checkX = cx;
      checkY = cy - 1;
    } else if (bg === 193 || bg === 1024 + 193 || bg === 2048 + 193 || bg === 3072 + 193) {
      checkX = cx - 1;
      checkY = cy - 1;
    }
    if (checkX >= 0) {
      // hit checkpoint
      if (checkpoint === false || checkX !== checkpoint.x || checkY !== checkpoint.y) {
        // remove last checkpoint
        if (checkpoint && !checkpoint.init)
          updateCheckpointTiles(checkpoint.x, checkpoint.y, -2);
        updateCheckpointTiles(checkX, checkY, 2);
        checkpoint = {
          x: checkX,
          y: checkY,
        };
      }
    }

    // move user
    let remainderX = userX % 1;
    let currentSX = velX;
    let remainderY = userY % 1;
    let currentSY = velY;
    let ox, oy, osx, osy;
    let doneX = false;
    let doneY = false;
    grounded = false;

    function stepX() {
      // move player
      if (currentSX > 0) {
        // enough velocity to advance one pixel?
        if (currentSX + remainderX >= 1) {
          // advance one pixel
          userX += (1 - remainderX);
          userX = Math.floor(userX);
          currentSX -= (1 - remainderX);
          remainderX = 0;
        } else {
          // not enough velocity to advance one pixel, so just consume rest
          userX += currentSX;
          currentSX = 0;
        }
      } else if (currentSX < 0) {
        // any remainder?
        if (remainderX + currentSX < 0 && remainderX !== 0) {
          // transfer remainder
          currentSX += remainderX;
          userX -= remainderX;
          userX = Math.floor(userX);
          remainderX = 1; // go left next iteration
        } else {
          // not enough velocity to advance one pixel, so just consume rest
          userX += currentSX;
          currentSX = 0;
        }
      }

      // check for collision
      const { collide: userCollide, spike: userSpike, home: userHome } =
        overlaps(userX, userY);
      const { collide: itemCollide, spike: itemSpike } = overlaps(userX, userY - 9);
      if (grabItem && itemSpike)
        explodeItem();
      if (userSpike)
        explodeUser();
      if (userHome)
        checkBeatGame();
      if (userCollide || (grabItem && itemCollide)) {
        // revert
        userX = ox;
        velX = 0;
        currentSX = osx;
        pushed = currentSX < 0 ? -1 : currentSX > 0 ? 1 : false;
        doneX = true;
      } else if (ox !== userX) {
        pushed = false;
      }
    }

    function stepY() {
      // move player
      if (currentSY > 0) {
        // enough velocity to advance one pixel?
        if (currentSY + remainderY >= 1) {
          // advance one pixel
          userY += (1 - remainderY);
          userY = Math.floor(userY);
          currentSY -= (1 - remainderY);
          remainderY = 0;
        } else {
          // not enough velocity to advance one pixel, so just consume rest
          userY += currentSY;
          currentSY = 0;
        }
      } else if (currentSY < 0) {
        // any remainder?
        if (remainderY + currentSY < 0 && remainderY !== 0) {
          // transfer remainder
          currentSY += remainderY;
          userY -= remainderY;
          userY = Math.floor(userY);
          remainderY = 1; // go left next iteration
        } else {
          // not enough velocity to advance one pixel, so just consume rest
          userY += currentSY;
          currentSY = 0;
        }
      }

      // check for collision
      let userCollide, userSpike, userHome, itemCollide, itemSpike;
      const checkCollision = () => {
        const { collide: ucollide, spike: uspike, home: uhome } = overlaps(userX, userY);
        const { collide: icollide, spike: ispike } = overlaps(userX, userY - 9);
        userCollide = ucollide;
        userSpike = uspike;
        userHome = uhome;
        itemCollide = icollide;
        itemSpike = ispike;
        return ucollide || (grabItem && icollide);
      }
      let collision = checkCollision();
      if (collision && osy < -0.5) {
        // if we collided, then check if we are jumping up, and *near* a gap
        const checkAgain = (ux) => {
          if (Math.abs(ux) - userX > 2)
            return false;
          const old = userX;
          userX = ux;
          collision = checkCollision();
          if (collision) {
            userX = old;
            return false;
          }
          return true;
        };
        checkAgain(Math.floor(userX)) ||
        checkAgain(Math.floor(userX) - 1) ||
        checkAgain(Math.floor(userX) + 1) ||
        checkAgain(Math.floor(userX) - 2) ||
        checkAgain(Math.floor(userX) + 2);
      }

      if (grabItem && itemSpike)
        explodeItem();
      if (userSpike)
        explodeUser();
      if (userHome)
        checkBeatGame();
      if (collision) {
        // revert
        userY = oy;
        velY = 0;
        currentSY = osy;
        if (currentSY > 0) {
          const tx = (userX + 5) / 9;
          const ty = (userY + 5) / 9;
          const ncx = Math.floor(tx);
          const ncy = Math.floor(ty);
          const { solid } = getForce(ncx, ncy + 1);
          if (solid) {
            grounded = true;
            groundedPos = [ncx, ncy + 1];
          } else {
            grounded = false;
            const cx = Math.floor(userX / 9);
            const cy = Math.floor((userY + 1) / 9);
            const cw = Math.ceil((userX + 9) / 9);
            const ch = Math.ceil((userY + 1 + 9) / 9);
            for (let iy = cy; iy < ch && !grounded; iy++) {
              for (let ix = cx; ix < cw && !grounded; ix++) {
                if (getForce(ix, iy).solid) {
                  grounded = true;
                  groundedPos = [ix, iy];
                }
              }
            }
          }
        }
        doneY = true;
      }
    }

    if (!userDead) {
      while ((currentSX !== 0 && !doneX) || (currentSY !== 0 && !doneY)){
        ox = userX;
        oy = userY;
        osx = currentSX;
        osy = currentSY;
        stepX();
        stepY();
      }
    }

    if (Math.abs(velX) < epsilon)
      velX = 0;
    if (Math.abs(velY) < epsilon)
      velY = 0;
    if (Math.abs(Math.floor(userX) - userX) < epsilon)
      userX = Math.floor(userX);
    if (Math.abs(Math.floor(userY) - userY) < epsilon)
      userY = Math.floor(userY);
    if (Math.abs(Math.floor(userX + 1) - userX) < epsilon)
      userX = Math.floor(userX + 1);
    if (Math.abs(Math.floor(userY + 1) - userY) < epsilon)
      userY = Math.floor(userY + 1);

    // move camera towards user
    let targetX = userX - 75;
    let targetY = grounded ? userY - 95 : userY - 87;
    let cameraLag = cameraLagNormal;
    if (explosion.length > 0) {
      // erm, actually target the center of the explosion
      targetX = 0;
      targetY = 0;
      for (const ex of explosion) {
        targetX += ex.x * 9 + 5;
        targetY += ex.y * 9 + 5;
      }
      targetX /= explosion.length;
      targetY /= explosion.length;
      targetX -= 75;
      targetY -= 95;
      cameraLag = cameraLagExplosion;
      wasTargetingExplosions = 60;
    }
    const cameraDist = Math.max(
      Math.abs(followX - targetX),
      Math.abs(followY - targetY)
    );
    if (wasTargetingExplosions > 0)
      wasTargetingExplosions--;
    else if (cameraDist > 50) // if we're *really* far away, then make cameraLag fast
      cameraLag *= 1 + ((cameraDist - 50) / 10);
    followX -= (followX - targetX) * cameraLag;
    followY -= (followY - targetY) * cameraLag;
    if (Math.abs(followX - targetX) < 0.1)
      followX = targetX;
    if (Math.abs(followY - targetY) < 0.1)
      followY = targetY;
    if (follow === 1) {
      cameraX = followX;
      cameraY = followY;
    } else if (follow === 2) {
      cameraX = followX = targetX;
      cameraY = followY = targetY;
      follow = 1;
    }

    // advance explosions
    for (let i = 0; i < explosion.length; i++) {
      const ex = explosion[i];
      ex.blink--;
      if (ex.blink <= 0) {
        ex.blinkLeft--;
        const k = ex.x + ex.y * worldWidth;
        if (ex.blinkLeft > 0) {
          ex.blink = 30;
          const tile = (world[k] >> 15) & 0xfff;
          ex.state = 1 - ex.state;
          if (tile < 10) {
            world[k] = (world[k] & maskNoItem) | (
              (tile + (ex.state === 0 ? -1 : 1)) << 15
            );
          }
        } else {
          randomParticles(5, ex.x * 9 + 5, ex.y * 9 + 5, particleWhiteSparkle);
          world[k] = world[k] & maskNoItem;
          exploded.push(k);
          explode(ex.x - 1, ex.y, 10, 0);
          explode(ex.x + 1, ex.y, 10, 0);
          explode(ex.x, ex.y - 1, 10, 0);
          explode(ex.x, ex.y + 1, 10, 0);
          explosion.splice(i, 1);
          i--;
        }
      }
    }

    redraw();
  }

  let frameCount = 0;
  let nextFPS = Date.now() + 1000;
  let nextFrame = Date.now();
  function run() {
    const now = Date.now();
    let i = 0;
    while (nextFrame < now) {
      tick();
      input.hitReset = false;
      input.hitJump = false;
      input.hitGrab = false;
      frameCount++;
      if (now >= nextFPS) {
        fps.innerText = 'FPS: ' + frameCount;
        frameCount = 0;
        nextFPS = now + 1000;
      }
      nextFrame += 1000 / 60;
      i++;
      if (i >= 4) {
        // too slow :-(
        nextFrame = Date.now();
      }
    }
    setTimeout(run, 0);
  }
  run();
}

function drawTile(d, x, y){
  const flip = (d >> 12) & 7;
  d = d & 0xfff;
  const dx = (d & 63) * 9;
  const dy = ((d >> 6) & 63) * 9;
  switch (flip){
    case 0:
      ctx.setTransform(
        1, 0,
        0, 1,
        x, y
      );
      break;
    case 1:
      ctx.setTransform(
        0, 1,
        1, 0,
        x, y
      );
      break;
    case 2:
      ctx.setTransform(
        1, 0,
        0, -1,
        x, y + 9
      );
      break;
    case 3:
      ctx.setTransform(
        0, -1,
        1, 0,
        x, y + 9
      );
      break;
    case 4:
      ctx.setTransform(
        -1, 0,
        0, 1,
        x + 9, y
      );
      break;
    case 5:
      ctx.setTransform(
        0, 1,
        -1, 0,
        x + 9, y
      );
      break;
    case 6:
      ctx.setTransform(
        -1, 0,
        0, -1,
        x + 9, y + 9
      );
      break;
    case 7:
      ctx.setTransform(
        0, -1,
        -1, 0,
        x + 9, y + 9
      );
      break;
  }
  ctx.drawImage(img, dx, dy, 9, 9, 0, 0, 9, 9);
}

function drawUser(d, flipH, x, y){
  const dx = (d % 13) * 25;
  const dy = Math.floor(d / 13) * 25;
  if (flipH) {
    ctx.setTransform(
      -1, 0,
      0, 1,
      x + 25 - 8, y - 8
    );
  } else {
    ctx.setTransform(
      1, 0,
      0, 1,
      x - 8, y - 8
    );
  }
  ctx.drawImage(userImg, dx, dy, 25, 25, 0, 0, 25, 25);
}

function onKey(key, down){
  switch (key) {
    case 'w': input.debugUp = down; return true;
    case 's': input.debugDown = down; return true;
    case 'a': input.debugLeft = down; return true;
    case 'd': input.debugRight = down; return true;
    case ' ': input.debugSpace = down; return true;
    case 'ArrowUp': input.up = down; return true;
    case 'ArrowDown': input.down = down; return true;
    case 'ArrowLeft': input.left = down; return true;
    case 'ArrowRight': input.right = down; return true;
    case 'Enter':
      if (down && !input.reset)
        input.hitReset = true;
      input.reset = down;
      return true;
    case 'x':
      if (down && !input.jump)
        input.hitJump = true;
      input.jump = down;
      return true;
    case 'z':
      if (down && !input.jump)
        input.hitGrab = true;
      input.grab = down;
      return true;
  }
  return false;
}

function onKeyDown(e){
  if (onKey(e.key, true)) {
    e.preventDefault();
    e.stopPropagation();
    return false;
  }
}

function onKeyUp(e){
  if (onKey(e.key, false)) {
    e.preventDefault();
    e.stopPropagation();
    return false;
  }
}

function onBlur(){
  input.up = false;
  input.down = false;
  input.left = false;
  input.right = false;
  input.reset = false;
  input.hitReset = false;
  input.jump = false;
  input.hitJump = false;
  input.grab = false;
  input.hitGrab = false;
  input.debugUp = false;
  input.debugDown = false;
  input.debugLeft = false;
  input.debugRight = false;
  input.debugSpace = false;
}

window.addEventListener('keydown', onKeyDown);
window.addEventListener('keyup', onKeyUp);
window.addEventListener('blur', onBlur);

// load everything
Promise.all([
  new Promise((resolve) => {
    if (img.complete)
      resolve();
    else
      img.onload = resolve;
  }),
  new Promise((resolve) => {
    if (userImg.complete)
      resolve();
    else
      userImg.onload = resolve;
  }),
  fetch('./world.json').then(
    async (response) => {
      const w = await response.json();

      // calculate world offset
      const rangeX = [0, 0];
      const rangeY = [0, 0];
      for (const layer of w.layers) {
        rangeX[0] = Math.min(rangeX[0], layer.startx);
        rangeX[1] = Math.max(rangeX[1], layer.startx + layer.width);
        rangeY[0] = Math.min(rangeY[0], layer.starty);
        rangeY[1] = Math.max(rangeY[1], layer.starty + layer.height);
      }

      worldWidth = rangeX[1] - rangeX[0];
      worldHeight = rangeY[1] - rangeY[0];
      for (let i = 0; i < worldWidth * worldHeight; i++)
        world.push(0);

      function loadLayer(name) {
        const layer = w.layers.find(layer => layer.name === name);
        if (!layer)
          throw new Error('Missing layer: ' + name);
        for (const chunk of layer.chunks) {
          for (let y = 0; y < chunk.height; y++) {
            for (let x = 0; x < chunk.width; x++) {
              let d = chunk.data[x + y * chunk.width] - 1;
              const flipH = (d & 0x80000000) !== 0;
              const flipV = (d & 0x40000000) !== 0;
              const flipR = (d & 0x20000000) !== 0;
              d = d < 0 ? d : d & 0xfff;
              const wx = chunk.x + x - rangeX[0];
              const wy = chunk.y + y - rangeY[0];
              const k = wx + wy * worldWidth;
              if (name === 'objects' && d === 1) {
                userX = wx * 9;
                userY = wy * 9;
                finalHome = [wx, wy];
                checkpoint = {
                  x: wx,
                  y: wy,
                  init: true
                }
              } else if (name === 'objects' && isPrize(d)) {
                const p = prizes.findIndex(p => p.item === d);
                if (p < 0)
                  prizes.push({ item: d, x: wx, y: wy, hx: 0, hy: 0, done: false });
                else {
                  prizes[p].x = wx;
                  prizes[p].y = wy;
                }
              } else if (d > 0) {
                if (isPrizeHome(d)) {
                  const item = d - 85 + 21;
                  const p = prizes.findIndex(p => p.item === item);
                  if (p < 0)
                    prizes.push({ item, x: -1, y: -1, hx: wx, hy: wy, done: false });
                  else {
                    prizes[p].hx = wx;
                    prizes[p].hy = wy;
                  }
                } else if (isPrizeDoors(d)) {
                  prizeDoors.push(k);
                } else if (isCoinDoors(d)) {
                  coinDoors.push(k);
                } else if (d === 26) { // coin
                  totalCoinCount++;
                } else {
                  d = d |
                    (flipH ? 0x4000 : 0) |
                    (flipV ? 0x2000 : 0) |
                    (flipR ? 0x1000 : 0);
                }
                if (name === 'objects') {
                  world[k] = world[k] | (d << 15);
                } else {
                  world[k] = (name === 'solid' ? 0x40000000 : 0) | d;
                }
              }
            }
          }
        }
      }

      loadLayer('background');
      loadLayer('solid');
      loadLayer('objects');
      for (const w of world)
        origWorld.push(w);
      // place prizes
      for (const p of prizes) {
        world[p.x + p.y * worldWidth] =
          (world[p.x + p.y * worldWidth] & maskNoItem) | (p.item << 15);
      }
    }
  )
]).then(start);
  </script>
</body>
</html>
